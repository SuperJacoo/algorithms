## binary_tree

### 一、二叉树的遍历

这里有个递归序的概念
```
    1
   / \    
  2   3

function preOrderRecur(head) {
    if (!head) {
        return null
    }
    // 1
    preOrderRecur(head.left)
    // 2
    preOrderRecur(head.right)
    // 3
}

对于任何一个节点都有三次访问该节点的机会。第一步、第二步、第三步
1   2   2   2   
1   3   3   3
1
以上节点的递归序就是 1  2   2   2   1   3   3   3   1

而前序遍历就是第一次访问该节点就打印
中序遍历是第二次访问该节点时打印
后序遍历是第三次访问该节点时打印

```
系统之所以可以通过递归打印树结构。是因为系统中有个强大的系统栈，可以对任意一节点 **访问三次**。

而我们虽然不能做到和**系统栈**如此强大，但是可以构造一个栈结构。遍历打印二叉树。

#### 1、前序遍历的非递归操作是使用栈操作。
**先打印节点，然后右孩子入栈，左孩子入栈，打印时就会先打印左孩子**。

```
        5
      /  \
     3    8
    / \   /\      
   2   4 7 10
 /      /  / \
1      6  9  11    
```

#### 2、前序遍历的非递归操作
中序遍历是把左侧一排放入栈中，然后依次出栈。出栈过程中，如果节点有右孩子，再把该右孩子的左侧一排放入栈中。。。。

节点都重复以上操作。当栈是空或者head(当前操作的节点都是空)时，跳出该循环。

#### 3、后序遍历的非递归操作

把前序遍历倒过来基本就后序遍历的非递归操作了

[code](https://github.com/zhangwinning/dataStructure/blob/master/zuochengyun/binary_tree/PreInPosTraversal.js)

### 二、判断一个树是否为搜索二叉树(BST)